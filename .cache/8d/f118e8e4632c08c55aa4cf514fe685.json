{"id":"../node_modules/@projectstorm/geometry/dist/es/Polygon.js","dependencies":[{"name":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\Polygon.js.map","includedInParent":true,"mtime":1594481777974},{"name":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\src\\Polygon.ts","includedInParent":true,"mtime":1594481777974},{"name":"C:\\myprojects\\groupthink\\Groupthink\\package.json","includedInParent":true,"mtime":1594485675900},{"name":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\package.json","includedInParent":true,"mtime":1594481777974},{"name":"./Point","loc":{"line":4,"column":24},"parent":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\Polygon.js","resolved":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\Point.js"},{"name":"lodash","loc":{"line":5,"column":18},"parent":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\Polygon.js","resolved":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\lodash\\lodash.js"},{"name":"./Rectangle","loc":{"line":114,"column":28},"parent":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\Polygon.js","resolved":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\Rectangle.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polygon = void 0;\nconst Point_1 = require(\"./Point\");\nconst _ = require(\"lodash\");\nclass Polygon {\n    constructor(points = []) {\n        this.points = points;\n    }\n    serialize() {\n        return _.map(this.points, (point) => {\n            return [point.x, point.y];\n        });\n    }\n    deserialize(data) {\n        this.points = _.map(data, (point) => {\n            return new Point_1.Point(point[0], point[1]);\n        });\n    }\n    scale(x, y, origin) {\n        let matrix = Point_1.Point.createScaleMatrix(x, y, origin);\n        _.forEach(this.points, (point) => {\n            point.transform(matrix);\n        });\n    }\n    transform(matrix) {\n        _.forEach(this.points, (point) => {\n            point.transform(matrix);\n        });\n    }\n    setPoints(points) {\n        this.points = points;\n    }\n    getPoints() {\n        return this.points;\n    }\n    rotate(degrees) {\n        this.transform(Point_1.Point.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));\n    }\n    translate(offsetX, offsetY) {\n        _.forEach(this.points, (point) => {\n            point.translate(offsetX, offsetY);\n        });\n    }\n    doClone(ob) {\n        this.points = _.map(ob.points, (point) => {\n            return point.clone();\n        });\n    }\n    clone() {\n        let ob = Object.create(this);\n        ob.doClone(this);\n        return ob;\n    }\n    getOrigin() {\n        if (this.points.length === 0) {\n            return null;\n        }\n        let dimensions = this.getBoundingBox();\n        return Point_1.Point.middlePoint(dimensions.getTopLeft(), dimensions.getBottomRight());\n    }\n    static boundingBoxFromPolygons(polygons) {\n        return Polygon.boundingBoxFromPoints(_.flatMap(polygons, (polygon) => {\n            return polygon.getPoints();\n        }));\n    }\n    static boundingBoxFromPoints(points) {\n        if (points.length === 0) {\n            return new Rectangle_1.Rectangle(0, 0, 0, 0);\n        }\n        let minX = points[0].x;\n        let maxX = points[0].x;\n        let minY = points[0].y;\n        let maxY = points[0].y;\n        for (let i = 1; i < points.length; i++) {\n            if (points[i].x < minX) {\n                minX = points[i].x;\n            }\n            if (points[i].x > maxX) {\n                maxX = points[i].x;\n            }\n            if (points[i].y < minY) {\n                minY = points[i].y;\n            }\n            if (points[i].y > maxY) {\n                maxY = points[i].y;\n            }\n        }\n        return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n    }\n    getBoundingBox() {\n        let minX = this.points[0].x;\n        let maxX = this.points[0].x;\n        let minY = this.points[0].y;\n        let maxY = this.points[0].y;\n        for (let i = 1; i < this.points.length; i++) {\n            if (this.points[i].x < minX) {\n                minX = this.points[i].x;\n            }\n            if (this.points[i].x > maxX) {\n                maxX = this.points[i].x;\n            }\n            if (this.points[i].y < minY) {\n                minY = this.points[i].y;\n            }\n            if (this.points[i].y > maxY) {\n                maxY = this.points[i].y;\n            }\n        }\n        return new Rectangle_1.Rectangle(new Point_1.Point(minX, minY), new Point_1.Point(maxX, minY), new Point_1.Point(maxX, maxY), new Point_1.Point(minX, maxY));\n    }\n}\nexports.Polygon = Polygon;\nconst Rectangle_1 = require(\"./Rectangle\");\n"},"sourceMaps":{"js":{"version":3,"file":"Polygon.js","sourceRoot":"","sources":["../../src/Polygon.ts"],"names":[],"mappings":";;;AAAA,mCAAgC;AAChC,4BAA4B;AAG5B,MAAa,OAAO;IAGnB,YAAY,SAAkB,EAAE;QAC/B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACtB,CAAC;IAED,SAAS;QACR,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE;YACnC,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,WAAW,CAAC,IAAS;QACpB,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,CAAC,KAAK,EAAE,EAAE;YACnC,OAAO,IAAI,aAAK,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,KAAK,CAAC,CAAC,EAAE,CAAC,EAAE,MAAa;QACxB,IAAI,MAAM,GAAG,aAAK,CAAC,iBAAiB,CAAC,CAAC,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;QACnD,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE;YAChC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,SAAS,CAAC,MAAc;QACvB,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE;YAChC,KAAK,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;QACzB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,SAAS,CAAC,MAAe;QACxB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACtB,CAAC;IAED,SAAS;QACR,OAAO,IAAI,CAAC,MAAM,CAAC;IACpB,CAAC;IAED,MAAM,CAAC,OAAe;QACrB,IAAI,CAAC,SAAS,CAAC,aAAK,CAAC,kBAAkB,CAAC,OAAO,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,EAAE,CAAC,EAAE,IAAI,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;IACvF,CAAC;IAED,SAAS,CAAC,OAAe,EAAE,OAAe;QACzC,CAAC,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE;YAChC,KAAK,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACnC,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,CAAC,EAAQ;QACf,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,KAAK,EAAE,EAAE;YACxC,OAAO,KAAK,CAAC,KAAK,EAAE,CAAC;QACtB,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,KAAK;QACJ,IAAI,EAAE,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;QAC7B,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;QACjB,OAAO,EAAE,CAAC;IACX,CAAC;IAED,SAAS;QACR,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,OAAO,IAAI,CAAC;SACZ;QACD,IAAI,UAAU,GAAG,IAAI,CAAC,cAAc,EAAE,CAAC;QACvC,OAAO,aAAK,CAAC,WAAW,CAAC,UAAU,CAAC,UAAU,EAAE,EAAE,UAAU,CAAC,cAAc,EAAE,CAAC,CAAC;IAChF,CAAC;IAED,MAAM,CAAC,uBAAuB,CAAC,QAAmB;QACjD,OAAO,OAAO,CAAC,qBAAqB,CACnC,CAAC,CAAC,OAAO,CAAC,QAAQ,EAAE,CAAC,OAAO,EAAE,EAAE;YAC/B,OAAO,OAAO,CAAC,SAAS,EAAE,CAAC;QAC5B,CAAC,CAAC,CACF,CAAC;IACH,CAAC;IAED,MAAM,CAAC,qBAAqB,CAAC,MAAe;QAC3C,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;YACxB,OAAO,IAAI,qBAAS,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;SACjC;QAED,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACvB,IAAI,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAEvB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACvC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBACvB,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACnB;YACD,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBACvB,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACnB;YACD,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBACvB,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACnB;YACD,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBACvB,IAAI,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACnB;SACD;QAED,OAAO,IAAI,qBAAS,CAAC,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;IAClH,CAAC;IAED,cAAc;QACb,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAC5B,IAAI,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QAE5B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC5C,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBAC5B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACxB;YACD,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBAC5B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACxB;YACD,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBAC5B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACxB;YACD,IAAI,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,IAAI,EAAE;gBAC5B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;aACxB;SACD;QAED,OAAO,IAAI,qBAAS,CAAC,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,EAAE,IAAI,aAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;IAClH,CAAC;CACD;AAjID,0BAiIC;AAED,2CAAwC","sourcesContent":["import { Point } from './Point';\nimport * as _ from 'lodash';\nimport { Matrix } from 'ml-matrix';\n\nexport class Polygon {\n\tprotected points: Point[];\n\n\tconstructor(points: Point[] = []) {\n\t\tthis.points = points;\n\t}\n\n\tserialize() {\n\t\treturn _.map(this.points, (point) => {\n\t\t\treturn [point.x, point.y];\n\t\t});\n\t}\n\n\tdeserialize(data: any) {\n\t\tthis.points = _.map(data, (point) => {\n\t\t\treturn new Point(point[0], point[1]);\n\t\t});\n\t}\n\n\tscale(x, y, origin: Point) {\n\t\tlet matrix = Point.createScaleMatrix(x, y, origin);\n\t\t_.forEach(this.points, (point) => {\n\t\t\tpoint.transform(matrix);\n\t\t});\n\t}\n\n\ttransform(matrix: Matrix) {\n\t\t_.forEach(this.points, (point) => {\n\t\t\tpoint.transform(matrix);\n\t\t});\n\t}\n\n\tsetPoints(points: Point[]) {\n\t\tthis.points = points;\n\t}\n\n\tgetPoints(): Point[] {\n\t\treturn this.points;\n\t}\n\n\trotate(degrees: number) {\n\t\tthis.transform(Point.createRotateMatrix(degrees / (180 / Math.PI), this.getOrigin()));\n\t}\n\n\ttranslate(offsetX: number, offsetY: number) {\n\t\t_.forEach(this.points, (point) => {\n\t\t\tpoint.translate(offsetX, offsetY);\n\t\t});\n\t}\n\n\tdoClone(ob: this) {\n\t\tthis.points = _.map(ob.points, (point) => {\n\t\t\treturn point.clone();\n\t\t});\n\t}\n\n\tclone(): this {\n\t\tlet ob = Object.create(this);\n\t\tob.doClone(this);\n\t\treturn ob;\n\t}\n\n\tgetOrigin(): Point {\n\t\tif (this.points.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tlet dimensions = this.getBoundingBox();\n\t\treturn Point.middlePoint(dimensions.getTopLeft(), dimensions.getBottomRight());\n\t}\n\n\tstatic boundingBoxFromPolygons(polygons: Polygon[]): Rectangle {\n\t\treturn Polygon.boundingBoxFromPoints(\n\t\t\t_.flatMap(polygons, (polygon) => {\n\t\t\t\treturn polygon.getPoints();\n\t\t\t})\n\t\t);\n\t}\n\n\tstatic boundingBoxFromPoints(points: Point[]): Rectangle {\n\t\tif (points.length === 0) {\n\t\t\treturn new Rectangle(0, 0, 0, 0);\n\t\t}\n\n\t\tlet minX = points[0].x;\n\t\tlet maxX = points[0].x;\n\t\tlet minY = points[0].y;\n\t\tlet maxY = points[0].y;\n\n\t\tfor (let i = 1; i < points.length; i++) {\n\t\t\tif (points[i].x < minX) {\n\t\t\t\tminX = points[i].x;\n\t\t\t}\n\t\t\tif (points[i].x > maxX) {\n\t\t\t\tmaxX = points[i].x;\n\t\t\t}\n\t\t\tif (points[i].y < minY) {\n\t\t\t\tminY = points[i].y;\n\t\t\t}\n\t\t\tif (points[i].y > maxY) {\n\t\t\t\tmaxY = points[i].y;\n\t\t\t}\n\t\t}\n\n\t\treturn new Rectangle(new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY));\n\t}\n\n\tgetBoundingBox(): Rectangle {\n\t\tlet minX = this.points[0].x;\n\t\tlet maxX = this.points[0].x;\n\t\tlet minY = this.points[0].y;\n\t\tlet maxY = this.points[0].y;\n\n\t\tfor (let i = 1; i < this.points.length; i++) {\n\t\t\tif (this.points[i].x < minX) {\n\t\t\t\tminX = this.points[i].x;\n\t\t\t}\n\t\t\tif (this.points[i].x > maxX) {\n\t\t\t\tmaxX = this.points[i].x;\n\t\t\t}\n\t\t\tif (this.points[i].y < minY) {\n\t\t\t\tminY = this.points[i].y;\n\t\t\t}\n\t\t\tif (this.points[i].y > maxY) {\n\t\t\t\tmaxY = this.points[i].y;\n\t\t\t}\n\t\t}\n\n\t\treturn new Rectangle(new Point(minX, minY), new Point(maxX, minY), new Point(maxX, maxY), new Point(minX, maxY));\n\t}\n}\n\nimport { Rectangle } from './Rectangle';\n"]}},"error":null,"hash":"05167055a27c470db824313dd5fa4029","cacheData":{"env":{}}}