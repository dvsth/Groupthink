{"id":"../node_modules/@projectstorm/react-diagrams-core/dist/es/DiagramEngine.js","dependencies":[{"name":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\dist\\es\\DiagramEngine.js.map","includedInParent":true,"mtime":1594481777956},{"name":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\src\\DiagramEngine.ts","includedInParent":true,"mtime":1594481777956},{"name":"C:\\myprojects\\groupthink\\Groupthink\\package.json","includedInParent":true,"mtime":1594485675900},{"name":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\package.json","includedInParent":true,"mtime":1594481777956},{"name":"./entities/node/NodeModel","loc":{"line":4,"column":28},"parent":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\dist\\es\\DiagramEngine.js","resolved":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\dist\\es\\entities\\node\\NodeModel.js"},{"name":"@projectstorm/geometry","loc":{"line":5,"column":27},"parent":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\dist\\es\\DiagramEngine.js","resolved":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\geometry\\dist\\es\\index.js"},{"name":"@projectstorm/react-canvas-core","loc":{"line":6,"column":36},"parent":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-diagrams-core\\dist\\es\\DiagramEngine.js","resolved":"C:\\myprojects\\groupthink\\Groupthink\\node_modules\\@projectstorm\\react-canvas-core\\dist\\es\\index.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagramEngine = void 0;\nconst NodeModel_1 = require(\"./entities/node/NodeModel\");\nconst geometry_1 = require(\"@projectstorm/geometry\");\nconst react_canvas_core_1 = require(\"@projectstorm/react-canvas-core\");\n/**\n * Passed as a parameter to the DiagramWidget\n */\nclass DiagramEngine extends react_canvas_core_1.CanvasEngine {\n    constructor(options = {}) {\n        super(options);\n        this.maxNumberPointsPerLink = 1000;\n        // create banks for the different factory types\n        this.nodeFactories = new react_canvas_core_1.FactoryBank();\n        this.linkFactories = new react_canvas_core_1.FactoryBank();\n        this.portFactories = new react_canvas_core_1.FactoryBank();\n        this.labelFactories = new react_canvas_core_1.FactoryBank();\n        const setup = (factory) => {\n            factory.registerListener({\n                factoryAdded: (event) => {\n                    event.factory.setDiagramEngine(this);\n                },\n                factoryRemoved: (event) => {\n                    event.factory.setDiagramEngine(null);\n                }\n            });\n        };\n        setup(this.nodeFactories);\n        setup(this.linkFactories);\n        setup(this.portFactories);\n        setup(this.labelFactories);\n    }\n    /**\n     * Gets a model and element under the mouse cursor\n     */\n    getMouseElement(event) {\n        var target = event.target;\n        var diagramModel = this.model;\n        //is it a port\n        var element = react_canvas_core_1.Toolkit.closest(target, '.port[data-name]');\n        if (element) {\n            var nodeElement = react_canvas_core_1.Toolkit.closest(target, '.node[data-nodeid]');\n            return diagramModel.getNode(nodeElement.getAttribute('data-nodeid')).getPort(element.getAttribute('data-name'));\n        }\n        //look for a point\n        element = react_canvas_core_1.Toolkit.closest(target, '.point[data-id]');\n        if (element) {\n            return diagramModel.getLink(element.getAttribute('data-linkid')).getPointModel(element.getAttribute('data-id'));\n        }\n        //look for a link\n        element = react_canvas_core_1.Toolkit.closest(target, '[data-linkid]');\n        if (element) {\n            return diagramModel.getLink(element.getAttribute('data-linkid'));\n        }\n        //look for a node\n        element = react_canvas_core_1.Toolkit.closest(target, '.node[data-nodeid]');\n        if (element) {\n            return diagramModel.getNode(element.getAttribute('data-nodeid'));\n        }\n        return null;\n    }\n    //!-------------- FACTORIES ------------\n    getNodeFactories() {\n        return this.nodeFactories;\n    }\n    getLinkFactories() {\n        return this.linkFactories;\n    }\n    getLabelFactories() {\n        return this.labelFactories;\n    }\n    getPortFactories() {\n        return this.portFactories;\n    }\n    getFactoryForNode(node) {\n        if (typeof node === 'string') {\n            return this.nodeFactories.getFactory(node);\n        }\n        return this.nodeFactories.getFactory(node.getType());\n    }\n    getFactoryForLink(link) {\n        if (typeof link === 'string') {\n            return this.linkFactories.getFactory(link);\n        }\n        return this.linkFactories.getFactory(link.getType());\n    }\n    getFactoryForLabel(label) {\n        if (typeof label === 'string') {\n            return this.labelFactories.getFactory(label);\n        }\n        return this.labelFactories.getFactory(label.getType());\n    }\n    getFactoryForPort(port) {\n        if (typeof port === 'string') {\n            return this.portFactories.getFactory(port);\n        }\n        return this.portFactories.getFactory(port.getType());\n    }\n    generateWidgetForLink(link) {\n        return this.getFactoryForLink(link).generateReactWidget({ model: link });\n    }\n    generateWidgetForNode(node) {\n        return this.getFactoryForNode(node).generateReactWidget({ model: node });\n    }\n    getNodeElement(node) {\n        const selector = this.canvas.querySelector(`.node[data-nodeid=\"${node.getID()}\"]`);\n        if (selector === null) {\n            throw new Error('Cannot find Node element with nodeID: [' + node.getID() + ']');\n        }\n        return selector;\n    }\n    getNodePortElement(port) {\n        var selector = this.canvas.querySelector(`.port[data-name=\"${port.getName()}\"][data-nodeid=\"${port.getParent().getID()}\"]`);\n        if (selector === null) {\n            throw new Error('Cannot find Node Port element with nodeID: [' +\n                port.getParent().getID() +\n                '] and name: [' +\n                port.getName() +\n                ']');\n        }\n        return selector;\n    }\n    getPortCenter(port) {\n        return this.getPortCoords(port).getOrigin();\n    }\n    /**\n     * Calculate rectangular coordinates of the port passed in.\n     */\n    getPortCoords(port, element) {\n        if (!this.canvas) {\n            throw new Error('Canvas needs to be set first');\n        }\n        if (!element) {\n            element = this.getNodePortElement(port);\n        }\n        const sourceRect = element.getBoundingClientRect();\n        const point = this.getRelativeMousePoint({\n            clientX: sourceRect.left,\n            clientY: sourceRect.top\n        });\n        const zoom = this.model.getZoomLevel() / 100.0;\n        return new geometry_1.Rectangle(point.x, point.y, sourceRect.width / zoom, sourceRect.height / zoom);\n    }\n    /**\n     * Determine the width and height of the node passed in.\n     * It currently assumes nodes have a rectangular shape, can be overriden for customised shapes.\n     */\n    getNodeDimensions(node) {\n        if (!this.canvas) {\n            return {\n                width: 0,\n                height: 0\n            };\n        }\n        const nodeElement = this.getNodeElement(node);\n        const nodeRect = nodeElement.getBoundingClientRect();\n        return {\n            width: nodeRect.width,\n            height: nodeRect.height\n        };\n    }\n    /**\n     * Get nodes bounding box coordinates with or without margin\n     * @returns rectangle points in node layer coordinates\n     */\n    getBoundingNodesRect(nodes, margin) {\n        if (nodes) {\n            if (nodes.length === 0) {\n                return new geometry_1.Rectangle(0, 0, 0, 0);\n            }\n            let boundingBox = geometry_1.Polygon.boundingBoxFromPolygons(nodes.map((node) => node.getBoundingBox()));\n            if (margin) {\n                return new geometry_1.Rectangle(boundingBox.getTopLeft().x - margin, boundingBox.getTopLeft().y - margin, boundingBox.getWidth() + 2 * margin, boundingBox.getHeight() + 2 * margin);\n            }\n            return boundingBox;\n        }\n    }\n    zoomToFitNodes(margin) {\n        let nodesRect; // nodes bounding rectangle\n        let selectedNodes = this.model\n            .getSelectedEntities()\n            .filter((entity) => entity instanceof NodeModel_1.NodeModel)\n            .map((node) => node);\n        // no node selected\n        if (selectedNodes.length == 0) {\n            let allNodes = this.model\n                .getSelectionEntities()\n                .filter((entity) => entity instanceof NodeModel_1.NodeModel)\n                .map((node) => node);\n            // get nodes bounding box with margin\n            nodesRect = this.getBoundingNodesRect(allNodes, margin);\n        }\n        else {\n            // get nodes bounding box with margin\n            nodesRect = this.getBoundingNodesRect(selectedNodes, margin);\n        }\n        if (nodesRect) {\n            // there is something we should zoom on\n            let canvasRect = this.canvas.getBoundingClientRect();\n            let canvasTopLeftPoint = {\n                x: canvasRect.left,\n                y: canvasRect.top\n            };\n            let nodeLayerTopLeftPoint = {\n                x: canvasTopLeftPoint.x + this.getModel().getOffsetX(),\n                y: canvasTopLeftPoint.y + this.getModel().getOffsetY()\n            };\n            const xFactor = this.canvas.clientWidth / nodesRect.getWidth();\n            const yFactor = this.canvas.clientHeight / nodesRect.getHeight();\n            const zoomFactor = xFactor < yFactor ? xFactor : yFactor;\n            this.model.setZoomLevel(zoomFactor * 100);\n            let nodesRectTopLeftPoint = {\n                x: nodeLayerTopLeftPoint.x + nodesRect.getTopLeft().x * zoomFactor,\n                y: nodeLayerTopLeftPoint.y + nodesRect.getTopLeft().y * zoomFactor\n            };\n            this.model.setOffset(this.model.getOffsetX() + canvasTopLeftPoint.x - nodesRectTopLeftPoint.x, this.model.getOffsetY() + canvasTopLeftPoint.y - nodesRectTopLeftPoint.y);\n            this.repaintCanvas();\n        }\n    }\n    getMaxNumberPointsPerLink() {\n        return this.maxNumberPointsPerLink;\n    }\n    setMaxNumberPointsPerLink(max) {\n        this.maxNumberPointsPerLink = max;\n    }\n}\nexports.DiagramEngine = DiagramEngine;\n"},"sourceMaps":{"js":{"version":3,"file":"DiagramEngine.js","sourceRoot":"","sources":["../../src/DiagramEngine.ts"],"names":[],"mappings":"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","sourcesContent":["import { NodeModel } from './entities/node/NodeModel';\nimport { PortModel } from './entities/port/PortModel';\nimport { LinkModel } from './entities/link/LinkModel';\nimport { LabelModel } from './entities/label/LabelModel';\nimport { Point, Rectangle, Polygon } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport {\n\tAbstractModelFactory,\n\tAbstractReactFactory,\n\tBaseModel,\n\tCanvasEngine,\n\tFactoryBank,\n\tToolkit\n} from '@projectstorm/react-canvas-core';\nimport { CanvasEngineListener, CanvasEngineOptions } from '@projectstorm/react-canvas-core';\nimport { DiagramModel } from './models/DiagramModel';\n\n/**\n * Passed as a parameter to the DiagramWidget\n */\nexport class DiagramEngine extends CanvasEngine<CanvasEngineListener, DiagramModel> {\n\tprotected nodeFactories: FactoryBank<AbstractReactFactory<NodeModel, DiagramEngine>>;\n\tprotected linkFactories: FactoryBank<AbstractReactFactory<LinkModel, DiagramEngine>>;\n\tprotected portFactories: FactoryBank<AbstractModelFactory<PortModel, DiagramEngine>>;\n\tprotected labelFactories: FactoryBank<AbstractReactFactory<LabelModel, DiagramEngine>>;\n\n\tmaxNumberPointsPerLink: number;\n\n\tconstructor(options: CanvasEngineOptions = {}) {\n\t\tsuper(options);\n\t\tthis.maxNumberPointsPerLink = 1000;\n\n\t\t// create banks for the different factory types\n\t\tthis.nodeFactories = new FactoryBank();\n\t\tthis.linkFactories = new FactoryBank();\n\t\tthis.portFactories = new FactoryBank();\n\t\tthis.labelFactories = new FactoryBank();\n\n\t\tconst setup = (factory: FactoryBank) => {\n\t\t\tfactory.registerListener({\n\t\t\t\tfactoryAdded: (event) => {\n\t\t\t\t\tevent.factory.setDiagramEngine(this);\n\t\t\t\t},\n\t\t\t\tfactoryRemoved: (event) => {\n\t\t\t\t\tevent.factory.setDiagramEngine(null);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\tsetup(this.nodeFactories);\n\t\tsetup(this.linkFactories);\n\t\tsetup(this.portFactories);\n\t\tsetup(this.labelFactories);\n\t}\n\n\t/**\n\t * Gets a model and element under the mouse cursor\n\t */\n\tgetMouseElement(event: MouseEvent): BaseModel {\n\t\tvar target = event.target as Element;\n\t\tvar diagramModel = this.model;\n\n\t\t//is it a port\n\t\tvar element = Toolkit.closest(target, '.port[data-name]');\n\t\tif (element) {\n\t\t\tvar nodeElement = Toolkit.closest(target, '.node[data-nodeid]') as HTMLElement;\n\t\t\treturn diagramModel.getNode(nodeElement.getAttribute('data-nodeid')).getPort(element.getAttribute('data-name'));\n\t\t}\n\n\t\t//look for a point\n\t\telement = Toolkit.closest(target, '.point[data-id]');\n\t\tif (element) {\n\t\t\treturn diagramModel.getLink(element.getAttribute('data-linkid')).getPointModel(element.getAttribute('data-id'));\n\t\t}\n\n\t\t//look for a link\n\t\telement = Toolkit.closest(target, '[data-linkid]');\n\t\tif (element) {\n\t\t\treturn diagramModel.getLink(element.getAttribute('data-linkid'));\n\t\t}\n\n\t\t//look for a node\n\t\telement = Toolkit.closest(target, '.node[data-nodeid]');\n\t\tif (element) {\n\t\t\treturn diagramModel.getNode(element.getAttribute('data-nodeid'));\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t//!-------------- FACTORIES ------------\n\n\tgetNodeFactories() {\n\t\treturn this.nodeFactories;\n\t}\n\n\tgetLinkFactories() {\n\t\treturn this.linkFactories;\n\t}\n\n\tgetLabelFactories() {\n\t\treturn this.labelFactories;\n\t}\n\n\tgetPortFactories() {\n\t\treturn this.portFactories;\n\t}\n\n\tgetFactoryForNode<F extends AbstractReactFactory<NodeModel, DiagramEngine>>(node: NodeModel | string) {\n\t\tif (typeof node === 'string') {\n\t\t\treturn this.nodeFactories.getFactory(node);\n\t\t}\n\t\treturn this.nodeFactories.getFactory(node.getType());\n\t}\n\n\tgetFactoryForLink<F extends AbstractReactFactory<LinkModel, DiagramEngine>>(link: LinkModel | string) {\n\t\tif (typeof link === 'string') {\n\t\t\treturn this.linkFactories.getFactory<F>(link);\n\t\t}\n\t\treturn this.linkFactories.getFactory<F>(link.getType());\n\t}\n\n\tgetFactoryForLabel<F extends AbstractReactFactory<LabelModel, DiagramEngine>>(label: LabelModel) {\n\t\tif (typeof label === 'string') {\n\t\t\treturn this.labelFactories.getFactory(label);\n\t\t}\n\t\treturn this.labelFactories.getFactory(label.getType());\n\t}\n\n\tgetFactoryForPort<F extends AbstractModelFactory<PortModel, DiagramEngine>>(port: PortModel) {\n\t\tif (typeof port === 'string') {\n\t\t\treturn this.portFactories.getFactory<F>(port);\n\t\t}\n\t\treturn this.portFactories.getFactory<F>(port.getType());\n\t}\n\n\tgenerateWidgetForLink(link: LinkModel): JSX.Element {\n\t\treturn this.getFactoryForLink(link).generateReactWidget({ model: link });\n\t}\n\n\tgenerateWidgetForNode(node: NodeModel): JSX.Element {\n\t\treturn this.getFactoryForNode(node).generateReactWidget({ model: node });\n\t}\n\n\tgetNodeElement(node: NodeModel): Element {\n\t\tconst selector = this.canvas.querySelector(`.node[data-nodeid=\"${node.getID()}\"]`);\n\t\tif (selector === null) {\n\t\t\tthrow new Error('Cannot find Node element with nodeID: [' + node.getID() + ']');\n\t\t}\n\t\treturn selector;\n\t}\n\n\tgetNodePortElement(port: PortModel): any {\n\t\tvar selector = this.canvas.querySelector(\n\t\t\t`.port[data-name=\"${port.getName()}\"][data-nodeid=\"${port.getParent().getID()}\"]`\n\t\t);\n\t\tif (selector === null) {\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot find Node Port element with nodeID: [' +\n\t\t\t\t\tport.getParent().getID() +\n\t\t\t\t\t'] and name: [' +\n\t\t\t\t\tport.getName() +\n\t\t\t\t\t']'\n\t\t\t);\n\t\t}\n\t\treturn selector;\n\t}\n\n\tgetPortCenter(port: PortModel): Point {\n\t\treturn this.getPortCoords(port).getOrigin();\n\t}\n\n\t/**\n\t * Calculate rectangular coordinates of the port passed in.\n\t */\n\tgetPortCoords(port: PortModel, element?: HTMLDivElement): Rectangle {\n\t\tif (!this.canvas) {\n\t\t\tthrow new Error('Canvas needs to be set first');\n\t\t}\n\t\tif (!element) {\n\t\t\telement = this.getNodePortElement(port);\n\t\t}\n\t\tconst sourceRect = element.getBoundingClientRect();\n\t\tconst point = this.getRelativeMousePoint({\n\t\t\tclientX: sourceRect.left,\n\t\t\tclientY: sourceRect.top\n\t\t});\n\t\tconst zoom = this.model.getZoomLevel() / 100.0;\n\t\treturn new Rectangle(point.x, point.y, sourceRect.width / zoom, sourceRect.height / zoom);\n\t}\n\n\t/**\n\t * Determine the width and height of the node passed in.\n\t * It currently assumes nodes have a rectangular shape, can be overriden for customised shapes.\n\t */\n\tgetNodeDimensions(node: NodeModel): { width: number; height: number } {\n\t\tif (!this.canvas) {\n\t\t\treturn {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t}\n\n\t\tconst nodeElement = this.getNodeElement(node);\n\t\tconst nodeRect = nodeElement.getBoundingClientRect();\n\n\t\treturn {\n\t\t\twidth: nodeRect.width,\n\t\t\theight: nodeRect.height\n\t\t};\n\t}\n\n\t/**\n\t * Get nodes bounding box coordinates with or without margin\n\t * @returns rectangle points in node layer coordinates\n\t */\n\tgetBoundingNodesRect(nodes: NodeModel[], margin?: number): Rectangle {\n\t\tif (nodes) {\n\t\t\tif (nodes.length === 0) {\n\t\t\t\treturn new Rectangle(0, 0, 0, 0);\n\t\t\t}\n\n\t\t\tlet boundingBox = Polygon.boundingBoxFromPolygons(nodes.map((node) => node.getBoundingBox()));\n\t\t\tif (margin) {\n\t\t\t\treturn new Rectangle(\n\t\t\t\t\tboundingBox.getTopLeft().x - margin,\n\t\t\t\t\tboundingBox.getTopLeft().y - margin,\n\t\t\t\t\tboundingBox.getWidth() + 2 * margin,\n\t\t\t\t\tboundingBox.getHeight() + 2 * margin\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn boundingBox;\n\t\t}\n\t}\n\n\tzoomToFitNodes(margin?: number) {\n\t\tlet nodesRect; // nodes bounding rectangle\n\t\tlet selectedNodes = this.model\n\t\t\t.getSelectedEntities()\n\t\t\t.filter((entity) => entity instanceof NodeModel)\n\t\t\t.map((node) => node) as NodeModel[];\n\n\t\t// no node selected\n\t\tif (selectedNodes.length == 0) {\n\t\t\tlet allNodes = this.model\n\t\t\t\t.getSelectionEntities()\n\t\t\t\t.filter((entity) => entity instanceof NodeModel)\n\t\t\t\t.map((node) => node) as NodeModel[];\n\n\t\t\t// get nodes bounding box with margin\n\t\t\tnodesRect = this.getBoundingNodesRect(allNodes, margin);\n\t\t} else {\n\t\t\t// get nodes bounding box with margin\n\t\t\tnodesRect = this.getBoundingNodesRect(selectedNodes, margin);\n\t\t}\n\n\t\tif (nodesRect) {\n\t\t\t// there is something we should zoom on\n\t\t\tlet canvasRect = this.canvas.getBoundingClientRect();\n\t\t\tlet canvasTopLeftPoint = {\n\t\t\t\tx: canvasRect.left,\n\t\t\t\ty: canvasRect.top\n\t\t\t};\n\t\t\tlet nodeLayerTopLeftPoint = {\n\t\t\t\tx: canvasTopLeftPoint.x + this.getModel().getOffsetX(),\n\t\t\t\ty: canvasTopLeftPoint.y + this.getModel().getOffsetY()\n\t\t\t};\n\n\t\t\tconst xFactor = this.canvas.clientWidth / nodesRect.getWidth();\n\t\t\tconst yFactor = this.canvas.clientHeight / nodesRect.getHeight();\n\t\t\tconst zoomFactor = xFactor < yFactor ? xFactor : yFactor;\n\n\t\t\tthis.model.setZoomLevel(zoomFactor * 100);\n\n\t\t\tlet nodesRectTopLeftPoint = {\n\t\t\t\tx: nodeLayerTopLeftPoint.x + nodesRect.getTopLeft().x * zoomFactor,\n\t\t\t\ty: nodeLayerTopLeftPoint.y + nodesRect.getTopLeft().y * zoomFactor\n\t\t\t};\n\n\t\t\tthis.model.setOffset(\n\t\t\t\tthis.model.getOffsetX() + canvasTopLeftPoint.x - nodesRectTopLeftPoint.x,\n\t\t\t\tthis.model.getOffsetY() + canvasTopLeftPoint.y - nodesRectTopLeftPoint.y\n\t\t\t);\n\t\t\tthis.repaintCanvas();\n\t\t}\n\t}\n\n\tgetMaxNumberPointsPerLink(): number {\n\t\treturn this.maxNumberPointsPerLink;\n\t}\n\n\tsetMaxNumberPointsPerLink(max: number) {\n\t\tthis.maxNumberPointsPerLink = max;\n\t}\n}\n"]}},"error":null,"hash":"eba8aa6a36e00e7b343314fed64912e5","cacheData":{"env":{}}}